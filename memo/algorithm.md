# 3章 探索
## 線形探索
配列の先頭から各要素が目的の値と等しいかどうかを順番に調べる。効率は悪い。

## 2分探索
データが昇順、降順で並んでる場合に中央の値との大小関係をチェック、中央の値より小さければ前方、大きければ後方を調べる
これを繰り返す

## ハッシュ法
ハッシュ関数で要素の格納場所を決定する
要素のキーを引数とした関数を呼び出すだけでその位置を特定することができるので、データの種類によってはより高速なデータの検索が可能になる

# 6章 分割統治法
1. 与えられた問題を部分問題に「分割」する(Divide)
1. 部分問題を再帰的に解く(Solve)
1. 得られた部分問題の解を「統合」して、元の問題を解く(Conquer)

# 7章 高等的整列
## 7.1 マージソート
バブルソートなどのO(n^2)の初等的なあアルゴリズムは大きなサイズの配列に対しては実用的ではない  
マージソートは大きなサイズのデータに対応することのできる高等的なアルゴリズムである  
マージソートは配列全体を対象としてソートを行う  
1. 指定されたnこの要素を含む部分配列をそれぞれn/2この要素を含む二つの部分配列に分割する(Divide)
1. その二つの部分配列をそれぞれmergeSortでソートする(Solve)
1. 得られた2つのそーと済み部分配列をmergeにより結合する(Conquer)

マージソートの計算量はO(nlogn)になる  
マージソートは安定なソート  
マージソートは高速で安定なアルゴリズムだが、入力データを保持する配列以外に一時的なメモリ領域が必要になる特徴を持つ  

## 7.2 パーティション
パーティションの処理はO(n)のアルゴリズムになる  
不安定なソートなので注意  

## 7.3 クイックソート
クイックソートは次のような分割統治法に基づくアルゴリズムです
1. partitionにより対象の部分配列を前後2つの部分配列へ分割する(Divide)
1. 前方の部分配列に対してquickSortを行う(Solve)
1. 後方の部分配列に対してquickSortを行う(Solve)

クイックソートはpartitionの内部で離れた要素の交換を行うので安定なソートではない  
一方でマージソートがO(n)の外部メモリを必要としたのに対し、クイックソートは追加のメモリ領域を必要としない、いわゆるインプレースソートである  
クイックソートの平均計算量はO(nlogn)で一般的にもっとも高速なソートアルゴリズムとして知られているが、データの並びによっては(例えば、ソート済みのデータ)に対しては効率が悪くなり、最悪の場合O(n^2)の計算量になってしまう  
データのならびによっては再帰が深くなり、スタックオーバーフローが怒る可能性もある  

## 7.4 計数ソート
計数ソートは、入力配列Aの要素を後ろから選んでいくことで安定なソートになる  

# 8章 木
## 8.1 木構造
### 根付き木
- 根(root)と呼ばれる他と区別された1つの接点を持つ木を根付き木と呼ぶ
- 根は親を持たない

### 二分木
- 1つの親を持ち、全ての接点についてこの数が2以下である木を根付き二分木と呼ぶ

## 8.2 根付き木
- 木の高さをhとして各節点の深さを求めるアルゴリズムの計算量は各節点から親をたどっていくアルゴリズムの計算量はO(h)となり、すべての接点について深さを求めるとO(nh)のアルゴリズムになる
- 一方、再帰的に計算していくアルゴリズムは各節点を一度ずつ訪問するのでO(n)のアルゴリズムになる

## 8.3 二分木
- 高さを求めるアルゴリズムでは、各節点の左の子(存在する場合)の高さ+1と、右の子(存在する場合)の高さ+1の大きい方をその節点の高さとする処理を再帰的に行なっているのでO(n)のアルゴリズム






































